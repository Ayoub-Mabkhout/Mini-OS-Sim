/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package gui;

import end.user.ProcessGenerator;
import end.user.SystemClock;
import static gui.OSFrame.completedProcesses;
import java.util.ArrayList;
import java.util.Queue;
import processes.Frame;
import processes.Page;
import system.managers.MemoryManager;
import system.managers.Scheduler;

/**
 *
 * @author A.Mabkhout
 */
public class ProgramState {
    
    // Program state variables
    Queue<processes.Process> processQueue = OSFrame.processQueue;
    
    public static ArrayList<Long> responseTimes = new ArrayList <>(); 
    public static ArrayList<Long> turnaroundTimes = new ArrayList <>();
    public static ArrayList<Long> waitingTimes = new ArrayList <>();
    

    
    public static processes.Process newestProcess(){
        // returns the newest process generated by the ProcessGenerator
        // note that it does not guarantee that that process is in the queue, the queue might be full and the ProcessGenerator
        // might wait for a spot to free up while holding onto the latest process it had created
        return ProcessGenerator.newestProcess;
    }
    
    public static int replacedProcess(ArrayList<processes.Process> oldProcessList){
        // takes in the old process list (the processes displayed in the GUI, you'll have to create that list)
        // checks it agains the processQueue (OSFrame.processQueue) and returns the process 
        // from the oldProcessList that's missing from the new ProcessList
        // return the index of that process so that you replace the right process item in the GUI with the new process in the queue
        for(int i = 0; i < oldProcessList.size() ; i++){
            processes.Process p = oldProcessList.get(i);
            if(!(p==null || p == Scheduler.runningProcess || OSFrame.processQueue.contains(p))){
                return i;
            }

        }
        
        return -1;
        // return -1 if there was no change (no process removed)
        // meaning if the oldProcessList contains the same processes as the processQueue
    }
    
    public static processes.Process lastEnqueuedProcess(){
        /*
        if(OSFrame.processQueue.isEmpty() && Scheduler.runningProcess == null)
            return null;
        
        processes.Process newest = Scheduler.runningProcess;
        long max = newest.getArrivalTime();
        for(processes.Process p : OSFrame.processQueue){
            if(p.getArrivalTime() > max){
                max = p.arrivalTime;
                newest = p;
            }
        }
        return newest;
        */
        return Scheduler.lastEnqueued;
        // use the Process returned by this method to replace the process that has ended (the position of which is returned by...
        // ... the replacedProcess() method)
    }
    
    public static Queue<Page> getLoadedPages(){
        // gets loaded pages in order for them to be displayed in the appropriate frame
        return MemoryManager.loadedPages;
    }

    
    public long getResponseTimes()
    {
        int sum = 0; 
        for (long t : responseTimes){
            sum += t; 
        }
        long average = sum/responseTimes.size(); 
        return average; 
    }
    public long getTurnaroundTimes()
    {
        int sum = 0; 
        for (long t : turnaroundTimes){
            sum += t; 
        }
        long average = sum/turnaroundTimes.size(); 
        return average; 
    }
    public long getWaitingTimes()
    {
        int sum = 0; 
        for (long t : waitingTimes){
            sum += t; 
        }
        long average = sum/waitingTimes.size(); 
        return average;
    }
    
        public float getThroughput ()
    {
        float throughput; 
        long elapsedTime = OSFrame.endTime-OSFrame.startTime;
        System.err.println("Completed processes is: " + completedProcesses);
        System.err.println("start time is: " + OSFrame.startTime + "\n end time is: "+ OSFrame.endTime);
        throughput = (100*completedProcesses/elapsedTime); 
        System.err.println("Throughput is: " + throughput);
        return throughput; 
    }
    
    public double getThrashing()
    {
        
        double x = system.managers.MemoryManager.thrashing;
        double y = system.managers.MemoryManager.loadRequests ;
        System.err.println("Thrashing: " + x);
        System.err.println("Load requests: " + y);
        double percentage = x/y; 
        System.err.println("percentage "+percentage);
        return percentage*100; 
    }
}
